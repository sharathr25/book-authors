"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Injector_1 = require("./Injector");
var utils_1 = require("./utils");
var Module = /** @class */ (function () {
    /**
     * @param name The name of ne module
     * @param dependencies An array of dependencies modules
     */
    function Module(name, dependencies) {
        this.name = name;
        this.dependencies = dependencies;
        this.services = {};
        this.configHooks = [];
        this.runHooks = [];
    }
    /**
     * @returns The module name
     */
    Module.prototype.getName = function () {
        return this.name;
    };
    /**
     * @param injectable A config hook function
     * @returns The current module
     */
    Module.prototype.config = function (injectable) {
        if (!utils_1.isInjectable(injectable)) {
            throw new Error("Can't register config injectable " + injectable + " in " + this.getName());
        }
        this.configHooks.push(injectable);
        return this;
    };
    /**
     * @param {Injectable} injectable A run hook function
     * @returns {Module} The current module
     */
    Module.prototype.run = function (injectable) {
        if (!utils_1.isInjectable(injectable)) {
            throw new Error("Can't register run injectable " + injectable + " in " + this.getName());
        }
        this.runHooks.push(injectable);
        return this;
    };
    /**
     * Register a new service in the module
     * @param serviceName the service name
     * @param serviceClass The service class
     * @returns this
     */
    Module.prototype.service = function (serviceName, serviceClass) {
        if (!utils_1.isServiceName(serviceName)) {
            throw new Error("Can't register service in " + this.getName() + " with name " + serviceName + ". serviceName must match " + utils_1.serviceNameRegex);
        }
        if (!utils_1.isFunction(serviceClass)) {
            throw new Error("Can't register service in " + this.getName() + " with name " + serviceName + ". Invalid serviceClass " + serviceClass);
        }
        this.services[serviceName] = /** @class */ (function () {
            function class_1() {
            }
            class_1.prototype.$get = function ($injector) {
                return $injector.instantiate(serviceClass, { $name: serviceName });
            };
            return class_1;
        }());
        return this;
    };
    /**
     * Register a new service in the module by providing a factory
     * @param serviceName the name of the service
     * @param injectable The function responsible of creating the service instance.
     * @returns this
     */
    Module.prototype.factory = function (serviceName, injectable) {
        if (!utils_1.isServiceName(serviceName)) {
            throw new Error("Can't register factory in " + this.getName() + " with name " + serviceName + ". serviceName must match " + utils_1.serviceNameRegex);
        }
        if (!utils_1.isInjectable(injectable)) {
            throw new Error("Can't register factory in " + this.getName() + " with name " + serviceName + ". Invalid injectable " + injectable);
        }
        this.services[serviceName] = /** @class */ (function () {
            function class_2() {
            }
            class_2.prototype.$get = function ($injector) {
                return $injector.invoke(injectable, $injector, { $name: serviceName });
            };
            return class_2;
        }());
        return this;
    };
    /**
     * Register a new service in the module by providing a provider class
     * @param serviceName The service name
     * @param providerClass A provider constructor
     * @returns this
     */
    Module.prototype.provider = function (serviceName, providerClass) {
        if (!utils_1.isServiceName(serviceName)) {
            throw new Error("Can't register provider in " + this.getName() + " with name " + serviceName + ". serviceName must match " + utils_1.serviceNameRegex);
        }
        if (!utils_1.isFunction(providerClass)) {
            throw new Error("Can't register provider in " + this.getName() + " with name " + serviceName + ". Invalid providerClass " + providerClass);
        }
        this.services[serviceName] = providerClass;
        return this;
    };
    /**
     * Bootstrap the module
     * @return The module injector
     */
    Module.prototype.bootstrap = function () {
        var modules = [];
        var $injectors = [];
        var $injector = this._bootstrap(modules, $injectors);
        modules.push(this);
        $injectors.push($injector);
        // TODO maybe throw if a service instance try to be injected in the config hook
        modules.forEach(function (module, i) {
            module.configHooks.forEach(function (hook) { return $injectors[i].invoke(hook); });
        });
        modules.forEach(function (module, i) {
            module.runHooks.forEach(function (hook) { return $injectors[i].invoke(hook); });
        });
        return $injector;
    };
    /**
     * Bootstrap the module.
     * @param modules An array of module
     * @param $injectors An array of corresponding injector
     * @returns the newly created injector
     */
    Module.prototype._bootstrap = function (modules, $injectors) {
        var _this = this;
        var $injector = new Injector_1.Injector();
        Object.keys(this.services).forEach(function (serviceName) { return $injector.addProvider(serviceName, _this.services[serviceName]); });
        this.dependencies.forEach(function (dependency) {
            var moduleIndex = modules.indexOf(dependency);
            if (moduleIndex === -1) {
                $injectors.push(dependency._bootstrap(modules, $injectors));
                modules.push(dependency);
                moduleIndex = modules.length - 1;
            }
            $injector.addChild($injectors[moduleIndex]);
        });
        return $injector;
    };
    return Module;
}());
exports.Module = Module;
//# sourceMappingURL=Module.js.map